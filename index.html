<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>太阳系模拟器</title>
        <script>
            window.injectInfo = { env: 'PROD' }
        </script>
        <script>
            window.publicPath =
                'https://gw.alipayobjects.com/render/p/yuyan/180023180025879726/'
        </script>
        <script src="https://gw.alipayobjects.com/render/p/yuyan/180023180023774655/mini-app-log.js"></script>
        <script
            defer=""
            src="https://gw.alipayobjects.com/render/p/yuyan/180023180000534978/tailwind4.1.13.js"
        ></script>
        <link
            href="https://gw.alipayobjects.com/render/p/yuyan/180023180003946312/material-icons.css"
            rel="stylesheet"
        />
        <script
            defer=""
            src="https://gw.alipayobjects.com/render/p/yuyan/180023180023774655/mini_app_base.js"
        ></script>
        <script type="module">
            // 动态加载Three.js并创建太阳系
            import(
                'https://gw.alipayobjects.com/os/lib/three/0.176.0/build/three.module.min.js'
            )
                .then((THREE) => {
                    /**
                     * 太阳系模拟器主类
                     * 负责创建和管理整个太阳系3D场景，包括行星、太阳、光照、交互等
                     */
                    class SolarSystem {
                        /**
                         * 构造函数：初始化太阳系模拟器的所有属性和变量
                         */
                        constructor() {
                            this.scene = null
                            this.camera = null
                            this.renderer = null
                            this.planets = []
                            this.animationId = null
                            this.isPaused = false
                            this.speed = 1.0
                            this.mouseX = 0
                            this.mouseY = 0
                            this.targetRotationX = 0
                            this.targetRotationY = 0
                            this.currentRotationX = 0
                            this.currentRotationY = 0
                            this.isDragging = false
                            this.lastMouseX = 0
                            this.lastMouseY = 0
                            this.cameraDistance = 50

                            this.planetData = [
                                {
                                    name: '水星',
                                    radius: 0.4,
                                    distance: 6,
                                    speed: 4.15,
                                    color: 0x8c8c8c,
                                    diameter: '4,879 km',
                                    realDistance: '5790万 km',
                                    period: '88天',
                                    textureType: 'mercury',
                                },
                                {
                                    name: '金星',
                                    radius: 0.9,
                                    distance: 9,
                                    speed: 1.62,
                                    color: 0xffc649,
                                    diameter: '12,104 km',
                                    realDistance: '1.082亿 km',
                                    period: '225天',
                                    textureType: 'venus',
                                },
                                {
                                    name: '地球',
                                    radius: 1.0,
                                    distance: 12,
                                    speed: 1.0,
                                    color: 0x4169e1,
                                    diameter: '12,756 km',
                                    realDistance: '1.496亿 km',
                                    period: '365天',
                                    textureType: 'earth',
                                },
                                {
                                    name: '火星',
                                    radius: 0.5,
                                    distance: 15,
                                    speed: 0.53,
                                    color: 0xcd5c5c,
                                    diameter: '6,792 km',
                                    realDistance: '2.279亿 km',
                                    period: '687天',
                                    textureType: 'mars',
                                },
                                {
                                    name: '木星',
                                    radius: 2.5,
                                    distance: 22,
                                    speed: 0.084,
                                    color: 0xdaa520,
                                    diameter: '142,984 km',
                                    realDistance: '7.786亿 km',
                                    period: '12年',
                                    textureType: 'jupiter',
                                },
                                {
                                    name: '土星',
                                    radius: 2.0,
                                    distance: 28,
                                    speed: 0.034,
                                    color: 0xf4a460,
                                    diameter: '120,536 km',
                                    realDistance: '14.29亿 km',
                                    period: '29年',
                                    textureType: 'saturn',
                                },
                                {
                                    name: '天王星',
                                    radius: 1.5,
                                    distance: 34,
                                    speed: 0.012,
                                    color: 0x4fd0e0,
                                    diameter: '51,118 km',
                                    realDistance: '28.71亿 km',
                                    period: '84年',
                                    textureType: 'uranus',
                                },
                                {
                                    name: '海王星',
                                    radius: 1.4,
                                    distance: 40,
                                    speed: 0.006,
                                    color: 0x4169e1,
                                    diameter: '49,528 km',
                                    realDistance: '44.95亿 km',
                                    period: '165年',
                                    textureType: 'neptune',
                                },
                            ]

                            this.init()
                        }

                        /**
                         * 初始化方法：按顺序创建场景的各个部分
                         * 包括画布设置、场景创建、光源、太阳、行星和事件监听
                         */
                        init() {
                            this.setupCanvas()
                            this.createScene()
                            this.createLights()
                            this.createSun()
                            this.createPlanets()
                            this.setupEventListeners()
                            this.animate()
                        }

                        /**
                         * 设置画布尺寸，使其与窗口大小匹配
                         */
                        setupCanvas() {
                            const canvas = document.getElementById('canvas')
                            const container =
                                document.getElementById('container')
                            const screenWidth = window.innerWidth
                            const screenHeight = window.innerHeight

                            canvas.width = screenWidth
                            canvas.height = screenHeight
                        }

                        /**
                         * 创建Three.js场景、相机和渲染器
                         * 配置渲染器的阴影、色调映射、颜色空间等高级特性
                         */
                        createScene() {
                            this.scene = new THREE.Scene()

                            this.createSkybox()

                            this.camera = new THREE.PerspectiveCamera(
                                75,
                                window.innerWidth / window.innerHeight,
                                0.1,
                                1000
                            )
                            this.camera.position.set(0, 20, this.cameraDistance)
                            this.camera.lookAt(0, 0, 0)

                            this.renderer = new THREE.WebGLRenderer({
                                canvas: document.getElementById('canvas'),
                                antialias: true,
                                alpha: false,
                            })
                            this.renderer.setSize(
                                window.innerWidth,
                                window.innerHeight
                            )
                            this.renderer.shadowMap.enabled = true
                            this.renderer.shadowMap.type =
                                THREE.PCFSoftShadowMap
                            this.renderer.toneMapping =
                                THREE.ACESFilmicToneMapping
                            this.renderer.toneMappingExposure = 0.8
                            this.renderer.outputColorSpace =
                                THREE.SRGBColorSpace
                            this.renderer.physicallyCorrectLights = true
                            this.renderer.gammaFactor = 2.2
                            this.renderer.gammaOutput = true

                            this.scene.environment = new THREE.Color(0x000814)
                            this.scene.background = new THREE.Color(0x000814)
                        }

                        /**
                         * 创建天空盒（背景球体）
                         * 创建一个巨大的球体作为场景背景，并添加星空效果
                         */
                        createSkybox() {
                            const skyboxGeometry = new THREE.SphereGeometry(
                                500,
                                32,
                                32
                            )
                            const skyboxMaterial = new THREE.MeshBasicMaterial({
                                color: 0x000814,
                                side: THREE.BackSide,
                                fog: false,
                            })
                            const skybox = new THREE.Mesh(
                                skyboxGeometry,
                                skyboxMaterial
                            )
                            this.scene.add(skybox)

                            this.createStars()
                        }

                        /**
                         * 创建星空粒子系统
                         * 随机生成10000个星星点，分布在场景中，每个星星有随机亮度和位置
                         */
                        createStars() {
                            const starsGeometry = new THREE.BufferGeometry()
                            const starsVertices = []
                            const starsColors = []

                            for (let i = 0; i < 10000; i++) {
                                const x = (Math.random() - 0.5) * 1000
                                const y = (Math.random() - 0.5) * 1000
                                const z = (Math.random() - 0.5) * 1000
                                starsVertices.push(x, y, z)

                                const color = new THREE.Color()
                                const brightness = Math.random() * 0.8 + 0.2
                                color.setHSL(0.6, 0.1, brightness)
                                starsColors.push(color.r, color.g, color.b)
                            }

                            starsGeometry.setAttribute(
                                'position',
                                new THREE.Float32BufferAttribute(
                                    starsVertices,
                                    3
                                )
                            )
                            starsGeometry.setAttribute(
                                'color',
                                new THREE.Float32BufferAttribute(starsColors, 3)
                            )

                            const starsMaterial = new THREE.PointsMaterial({
                                size: 0.5,
                                vertexColors: true,
                                transparent: true,
                                opacity: 0.8,
                            })

                            const stars = new THREE.Points(
                                starsGeometry,
                                starsMaterial
                            )
                            this.scene.add(stars)
                        }

                        /**
                         * 根据行星类型创建对应的纹理
                         * @param {string} textureType - 行星类型（mercury, venus, earth等）
                         * @returns {THREE.CanvasTexture} 创建好的纹理对象
                         */
                        createPlanetTexture(textureType) {
                            const canvas = document.createElement('canvas')
                            canvas.width = 512
                            canvas.height = 256
                            const ctx = canvas.getContext('2d')

                            switch (textureType) {
                                case 'mercury':
                                    this.createMercuryTexture(ctx)
                                    break
                                case 'venus':
                                    this.createVenusTexture(ctx)
                                    break
                                case 'earth':
                                    this.createEarthTexture(ctx)
                                    break
                                case 'mars':
                                    this.createMarsTexture(ctx)
                                    break
                                case 'jupiter':
                                    this.createJupiterTexture(ctx)
                                    break
                                case 'saturn':
                                    this.createSaturnTexture(ctx)
                                    break
                                case 'uranus':
                                    this.createUranusTexture(ctx)
                                    break
                                case 'neptune':
                                    this.createNeptuneTexture(ctx)
                                    break
                                default:
                                    this.createDefaultTexture(ctx)
                            }

                            const texture = new THREE.CanvasTexture(canvas)
                            texture.needsUpdate = true
                            return texture
                        }

                        /**
                         * 创建水星纹理
                         * 水星表面呈灰色，有大量陨石坑和亮点
                         * @param {CanvasRenderingContext2D} ctx - Canvas 2D上下文
                         */
                        createMercuryTexture(ctx) {
                            const gradient = ctx.createLinearGradient(
                                0,
                                0,
                                512,
                                0
                            )
                            gradient.addColorStop(0, '#8C7853')
                            gradient.addColorStop(0.2, '#A0826D')
                            gradient.addColorStop(0.4, '#8B7355')
                            gradient.addColorStop(0.6, '#696969')
                            gradient.addColorStop(0.8, '#8B7355')
                            gradient.addColorStop(1, '#A0826D')
                            ctx.fillStyle = gradient
                            ctx.fillRect(0, 0, 512, 256)

                            for (let i = 0; i < 200; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 4 + 1
                                const opacity = Math.random() * 0.4

                                ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            for (let i = 0; i < 50; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 2 + 0.5

                                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }
                        }

                        /**
                         * 创建金星纹理
                         * 金星表面呈橙黄色，有云层和大气层效果
                         * @param {CanvasRenderingContext2D} ctx - Canvas 2D上下文
                         */
                        createVenusTexture(ctx) {
                            const gradient = ctx.createRadialGradient(
                                256,
                                128,
                                30,
                                256,
                                128,
                                200
                            )
                            gradient.addColorStop(0, '#FFF8DC')
                            gradient.addColorStop(0.2, '#FFE4B5')
                            gradient.addColorStop(0.4, '#FFD700')
                            gradient.addColorStop(0.6, '#FFC649')
                            gradient.addColorStop(0.8, '#FFA500')
                            gradient.addColorStop(1, '#FF8C00')
                            ctx.fillStyle = gradient
                            ctx.fillRect(0, 0, 512, 256)

                            for (let i = 0; i < 100; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 20 + 8
                                const opacity = Math.random() * 0.2

                                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            for (let i = 0; i < 40; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const width = Math.random() * 80 + 30
                                const height = Math.random() * 15 + 5

                                ctx.fillStyle = 'rgba(255, 140, 0, 0.25)'
                                ctx.fillRect(x, y, width, height)
                            }

                            const atmosphereGradient = ctx.createRadialGradient(
                                256,
                                128,
                                180,
                                256,
                                128,
                                220
                            )
                            atmosphereGradient.addColorStop(
                                0,
                                'rgba(255, 255, 255, 0)'
                            )
                            atmosphereGradient.addColorStop(
                                0.5,
                                'rgba(255, 215, 0, 0.1)'
                            )
                            atmosphereGradient.addColorStop(
                                1,
                                'rgba(255, 140, 0, 0.2)'
                            )
                            ctx.fillStyle = atmosphereGradient
                            ctx.fillRect(0, 0, 512, 256)
                        }

                        /**
                         * 创建地球纹理
                         * 包含海洋、大陆、云层等元素，模拟真实地球外观
                         * @param {CanvasRenderingContext2D} ctx - Canvas 2D上下文
                         */
                        createEarthTexture(ctx) {
                            const oceanGradient = ctx.createLinearGradient(
                                0,
                                0,
                                512,
                                0
                            )
                            oceanGradient.addColorStop(0, '#0066CC')
                            oceanGradient.addColorStop(0.2, '#0080FF')
                            oceanGradient.addColorStop(0.4, '#1E90FF')
                            oceanGradient.addColorStop(0.6, '#4169E1')
                            oceanGradient.addColorStop(0.8, '#0000CD')
                            oceanGradient.addColorStop(1, '#0066CC')
                            ctx.fillStyle = oceanGradient
                            ctx.fillRect(0, 0, 512, 256)

                            const continents = [
                                { x: 100, y: 80, w: 120, h: 60 },
                                { x: 250, y: 100, w: 80, h: 40 },
                                { x: 350, y: 60, w: 100, h: 50 },
                                { x: 50, y: 150, w: 90, h: 45 },
                                { x: 180, y: 160, w: 110, h: 55 },
                                { x: 320, y: 140, w: 85, h: 42 },
                                { x: 420, y: 180, w: 70, h: 35 },
                            ]

                            continents.forEach((continent) => {
                                const landGradient = ctx.createRadialGradient(
                                    continent.x + continent.w / 2,
                                    continent.y + continent.h / 2,
                                    0,
                                    continent.x + continent.w / 2,
                                    continent.y + continent.h / 2,
                                    Math.max(continent.w, continent.h) / 2
                                )
                                landGradient.addColorStop(0, '#32CD32')
                                landGradient.addColorStop(0.3, '#228B22')
                                landGradient.addColorStop(0.7, '#006400')
                                landGradient.addColorStop(1, '#2E7D32')

                                ctx.fillStyle = landGradient
                                ctx.fillRect(
                                    continent.x,
                                    continent.y,
                                    continent.w,
                                    continent.h
                                )
                            })

                            for (let i = 0; i < 50; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 25 + 8
                                const opacity = Math.random() * 0.4

                                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            for (let i = 0; i < 30; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 12 + 3

                                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            const cloudLayer = ctx.createLinearGradient(
                                0,
                                0,
                                512,
                                256
                            )
                            cloudLayer.addColorStop(0, 'rgba(255, 255, 255, 0)')
                            cloudLayer.addColorStop(
                                0.3,
                                'rgba(255, 255, 255, 0.1)'
                            )
                            cloudLayer.addColorStop(
                                0.5,
                                'rgba(255, 255, 255, 0.15)'
                            )
                            cloudLayer.addColorStop(
                                0.7,
                                'rgba(255, 255, 255, 0.1)'
                            )
                            cloudLayer.addColorStop(1, 'rgba(255, 255, 255, 0)')
                            ctx.fillStyle = cloudLayer
                            ctx.fillRect(0, 0, 512, 256)
                        }

                        /**
                         * 创建火星纹理
                         * 火星表面呈红色，有陨石坑、极地冰帽等特征
                         * @param {CanvasRenderingContext2D} ctx - Canvas 2D上下文
                         */
                        createMarsTexture(ctx) {
                            const gradient = ctx.createRadialGradient(
                                256,
                                128,
                                20,
                                256,
                                128,
                                200
                            )
                            gradient.addColorStop(0, '#FF4444')
                            gradient.addColorStop(0.2, '#FF6347')
                            gradient.addColorStop(0.4, '#CD5C5C')
                            gradient.addColorStop(0.6, '#B22222')
                            gradient.addColorStop(0.8, '#8B0000')
                            gradient.addColorStop(1, '#800000')
                            ctx.fillStyle = gradient
                            ctx.fillRect(0, 0, 512, 256)

                            for (let i = 0; i < 80; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 15 + 3
                                const opacity = Math.random() * 0.4

                                ctx.fillStyle = `rgba(139, 69, 19, ${opacity})`
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            for (let i = 0; i < 30; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const width = Math.random() * 50 + 15
                                const height = Math.random() * 12 + 3

                                ctx.fillStyle = 'rgba(160, 82, 45, 0.5)'
                                ctx.fillRect(x, y, width, height)
                            }

                            for (let i = 0; i < 20; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 8 + 2

                                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            const polarCapGradient1 = ctx.createRadialGradient(
                                256,
                                30,
                                0,
                                256,
                                30,
                                40
                            )
                            polarCapGradient1.addColorStop(
                                0,
                                'rgba(255, 255, 255, 0.8)'
                            )
                            polarCapGradient1.addColorStop(
                                0.5,
                                'rgba(255, 255, 255, 0.4)'
                            )
                            polarCapGradient1.addColorStop(
                                1,
                                'rgba(255, 255, 255, 0)'
                            )
                            ctx.fillStyle = polarCapGradient1
                            ctx.fillRect(200, 0, 112, 60)

                            const polarCapGradient2 = ctx.createRadialGradient(
                                256,
                                226,
                                0,
                                256,
                                226,
                                40
                            )
                            polarCapGradient2.addColorStop(
                                0,
                                'rgba(255, 255, 255, 0.8)'
                            )
                            polarCapGradient2.addColorStop(
                                0.5,
                                'rgba(255, 255, 255, 0.4)'
                            )
                            polarCapGradient2.addColorStop(
                                1,
                                'rgba(255, 255, 255, 0)'
                            )
                            ctx.fillStyle = polarCapGradient2
                            ctx.fillRect(200, 196, 112, 60)
                        }

                        /**
                         * 创建木星纹理
                         * 木星表面有横向条纹和大红斑（风暴），呈黄棕色
                         * @param {CanvasRenderingContext2D} ctx - Canvas 2D上下文
                         */
                        createJupiterTexture(ctx) {
                            const gradient = ctx.createLinearGradient(
                                0,
                                0,
                                0,
                                256
                            )
                            gradient.addColorStop(0, '#DAA520')
                            gradient.addColorStop(0.15, '#F4A460')
                            gradient.addColorStop(0.25, '#D2691E')
                            gradient.addColorStop(0.35, '#F4A460')
                            gradient.addColorStop(0.45, '#DAA520')
                            gradient.addColorStop(0.55, '#CD853F')
                            gradient.addColorStop(0.65, '#F4A460')
                            gradient.addColorStop(0.75, '#DEB887')
                            gradient.addColorStop(0.85, '#F4A460')
                            gradient.addColorStop(1, '#DAA520')
                            ctx.fillStyle = gradient
                            ctx.fillRect(0, 0, 512, 256)

                            for (let i = 0; i < 8; i++) {
                                const y = i * 32 + 16
                                const opacity = Math.random() * 0.3 + 0.1

                                ctx.strokeStyle = `rgba(139, 69, 19, ${opacity})`
                                ctx.lineWidth = Math.random() * 3 + 1
                                ctx.beginPath()
                                ctx.moveTo(0, y)
                                ctx.lineTo(512, y)
                                ctx.stroke()
                            }

                            const stormGradient = ctx.createRadialGradient(
                                400,
                                100,
                                0,
                                400,
                                100,
                                30
                            )
                            stormGradient.addColorStop(0, '#FF6347')
                            stormGradient.addColorStop(0.5, '#CD5C5C')
                            stormGradient.addColorStop(1, '#8B0000')
                            ctx.fillStyle = stormGradient
                            ctx.beginPath()
                            ctx.arc(400, 100, 25, 0, Math.PI * 2)
                            ctx.fill()

                            for (let i = 0; i < 40; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 8 + 2
                                const opacity = Math.random() * 0.2

                                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }
                        }

                        /**
                         * 创建土星纹理
                         * 土星表面呈淡黄色，有横向条纹和云层
                         * @param {CanvasRenderingContext2D} ctx - Canvas 2D上下文
                         */
                        createSaturnTexture(ctx) {
                            const gradient = ctx.createLinearGradient(
                                0,
                                0,
                                512,
                                0
                            )
                            gradient.addColorStop(0, '#F4A460')
                            gradient.addColorStop(0.2, '#FFDEAD')
                            gradient.addColorStop(0.4, '#FFE4B5')
                            gradient.addColorStop(0.6, '#DEB887')
                            gradient.addColorStop(0.8, '#FFE4B5')
                            gradient.addColorStop(1, '#F4A460')
                            ctx.fillStyle = gradient
                            ctx.fillRect(0, 0, 512, 256)

                            for (let i = 0; i < 15; i++) {
                                const y = i * 17 + 8
                                const opacity = Math.random() * 0.3 + 0.1

                                ctx.strokeStyle = `rgba(222, 184, 135, ${opacity})`
                                ctx.lineWidth = Math.random() * 2 + 0.5
                                ctx.beginPath()
                                ctx.moveTo(0, y)
                                ctx.lineTo(512, y)
                                ctx.stroke()
                            }

                            for (let i = 0; i < 25; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 6 + 1
                                const opacity = Math.random() * 0.25

                                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            for (let i = 0; i < 15; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 4 + 0.5

                                ctx.fillStyle = 'rgba(139, 90, 43, 0.3)'
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }
                        }

                        /**
                         * 创建天王星纹理
                         * 天王星表面呈青蓝色，有横向条纹和云层
                         * @param {CanvasRenderingContext2D} ctx - Canvas 2D上下文
                         */
                        createUranusTexture(ctx) {
                            const gradient = ctx.createRadialGradient(
                                256,
                                128,
                                20,
                                256,
                                128,
                                200
                            )
                            gradient.addColorStop(0, '#4FD0E0')
                            gradient.addColorStop(0.3, '#40E0D0')
                            gradient.addColorStop(0.6, '#48D1CC')
                            gradient.addColorStop(1, '#20B2AA')
                            ctx.fillStyle = gradient
                            ctx.fillRect(0, 0, 512, 256)

                            for (let i = 0; i < 12; i++) {
                                const y = i * 21 + 10
                                const opacity = Math.random() * 0.2 + 0.05

                                ctx.strokeStyle = `rgba(176, 224, 230, ${opacity})`
                                ctx.lineWidth = Math.random() * 2 + 0.5
                                ctx.beginPath()
                                ctx.moveTo(0, y)
                                ctx.lineTo(512, y)
                                ctx.stroke()
                            }

                            for (let i = 0; i < 30; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 8 + 2
                                const opacity = Math.random() * 0.3

                                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            for (let i = 0; i < 20; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 4 + 1

                                ctx.fillStyle = 'rgba(0, 139, 139, 0.2)'
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }
                        }

                        /**
                         * 创建海王星纹理
                         * 海王星表面呈深蓝色，有横向条纹和风暴特征
                         * @param {CanvasRenderingContext2D} ctx - Canvas 2D上下文
                         */
                        createNeptuneTexture(ctx) {
                            const gradient = ctx.createRadialGradient(
                                256,
                                128,
                                25,
                                256,
                                128,
                                200
                            )
                            gradient.addColorStop(0, '#4169E1')
                            gradient.addColorStop(0.2, '#1E90FF')
                            gradient.addColorStop(0.4, '#0000FF')
                            gradient.addColorStop(0.6, '#0000CD')
                            gradient.addColorStop(0.8, '#00008B')
                            gradient.addColorStop(1, '#000080')
                            ctx.fillStyle = gradient
                            ctx.fillRect(0, 0, 512, 256)

                            for (let i = 0; i < 12; i++) {
                                const y = i * 21 + 10
                                const opacity = Math.random() * 0.3 + 0.15

                                ctx.strokeStyle = `rgba(135, 206, 250, ${opacity})`
                                ctx.lineWidth = Math.random() * 4 + 1
                                ctx.beginPath()
                                ctx.moveTo(0, y)
                                ctx.lineTo(512, y)
                                ctx.stroke()
                            }

                            for (let i = 0; i < 45; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 12 + 4
                                const opacity = Math.random() * 0.5

                                ctx.fillStyle = `rgba(0, 0, 139, ${opacity})`
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            for (let i = 0; i < 35; i++) {
                                const x = Math.random() * 512
                                const y = Math.random() * 256
                                const radius = Math.random() * 8 + 2

                                ctx.fillStyle = 'rgba(173, 216, 230, 0.3)'
                                ctx.beginPath()
                                ctx.arc(x, y, radius, 0, Math.PI * 2)
                                ctx.fill()
                            }

                            const stormGradient = ctx.createRadialGradient(
                                150,
                                80,
                                0,
                                150,
                                80,
                                25
                            )
                            stormGradient.addColorStop(0, '#000080')
                            stormGradient.addColorStop(0.3, '#0000CD')
                            stormGradient.addColorStop(0.6, '#0000FF')
                            stormGradient.addColorStop(1, '#191970')
                            ctx.fillStyle = stormGradient
                            ctx.beginPath()
                            ctx.arc(150, 80, 20, 0, Math.PI * 2)
                            ctx.fill()

                            const stormGradient2 = ctx.createRadialGradient(
                                380,
                                160,
                                0,
                                380,
                                160,
                                20
                            )
                            stormGradient2.addColorStop(0, '#00008B')
                            stormGradient2.addColorStop(0.4, '#0000CD')
                            stormGradient2.addColorStop(0.8, '#4169E1')
                            stormGradient2.addColorStop(1, '#1E90FF')
                            ctx.fillStyle = stormGradient2
                            ctx.beginPath()
                            ctx.arc(380, 160, 18, 0, Math.PI * 2)
                            ctx.fill()
                        }

                        /**
                         * 创建默认纹理（灰色）
                         * 当行星类型不匹配时使用
                         * @param {CanvasRenderingContext2D} ctx - Canvas 2D上下文
                         */
                        createDefaultTexture(ctx) {
                            ctx.fillStyle = '#808080'
                            ctx.fillRect(0, 0, 512, 256)
                        }

                        /**
                         * 创建场景中的所有光源
                         * 使用多种光源组合（点光源、环境光、方向光等）以营造真实的太空光照效果
                         */
                        createLights() {
                            const sunLight = new THREE.PointLight(
                                0xffffff,
                                5,
                                100
                            )
                            sunLight.position.set(0, 0, 0)
                            sunLight.castShadow = true
                            sunLight.shadow.mapSize.width = 4096
                            sunLight.shadow.mapSize.height = 4096
                            sunLight.shadow.camera.near = 0.5
                            sunLight.shadow.camera.far = 100
                            sunLight.shadow.bias = -0.0001
                            sunLight.shadow.radius = 4
                            this.scene.add(sunLight)

                            const sunLightWarm = new THREE.PointLight(
                                0xffaa00,
                                2.5,
                                60
                            )
                            sunLightWarm.position.set(0, 0, 0)
                            this.scene.add(sunLightWarm)

                            const sunLightCool = new THREE.PointLight(
                                0x4488ff,
                                1.8,
                                40
                            )
                            sunLightCool.position.set(0, 0, 0)
                            this.scene.add(sunLightCool)

                            const ambientLight = new THREE.AmbientLight(
                                0x404040,
                                0.4
                            )
                            this.scene.add(ambientLight)

                            const hemisphereLight = new THREE.HemisphereLight(
                                0x87ceeb,
                                0x8b4513,
                                0.3
                            )
                            this.scene.add(hemisphereLight)

                            const directionalLight = new THREE.DirectionalLight(
                                0xffffff,
                                0.5
                            )
                            directionalLight.position.set(10, 10, 5)
                            directionalLight.castShadow = true
                            directionalLight.shadow.mapSize.width = 2048
                            directionalLight.shadow.mapSize.height = 2048
                            this.scene.add(directionalLight)

                            const fillLight = new THREE.DirectionalLight(
                                0x87ceeb,
                                0.2
                            )
                            fillLight.position.set(-10, 5, -5)
                            this.scene.add(fillLight)

                            const rimLight = new THREE.DirectionalLight(
                                0xffaa00,
                                0.3
                            )
                            rimLight.position.set(0, -10, -10)
                            this.scene.add(rimLight)
                        }

                        /**
                         * 创建太阳及其光晕效果
                         * 太阳使用自定义shader实现表面火焰闪动效果，配合多层光晕营造发光效果
                         */
                        createSun() {
                            const sunGeometry = new THREE.SphereGeometry(
                                3,
                                64,
                                64
                            )

                            // 自定义shader实现火焰闪动效果
                            const sunVertexShader = `
                                varying vec3 vPosition;
                                varying vec3 vNormal;
                                varying vec2 vUv;
                                
                                void main() {
                                    vPosition = position;
                                    vNormal = normalize(normalMatrix * normal);
                                    vUv = uv;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }
                            `

                            const sunFragmentShader = `
                                // based on https://www.shadertoy.com/view/lsf3RH by trisomie21
                                
                                uniform float uTime;
                                uniform vec3 uSunColor;
                                uniform vec3 uFlameColor;
                                
                                varying vec3 vPosition;
                                varying vec3 vNormal;
                                varying vec2 vUv;
                                
                                // 3D噪声函数 by trisomie21
                                float snoise(vec3 uv, float res) {
                                    const vec3 s = vec3(1e0, 1e2, 1e4);
                                    
                                    uv *= res;
                                    
                                    vec3 uv0 = floor(mod(uv, res)) * s;
                                    vec3 uv1 = floor(mod(uv + vec3(1.0), res)) * s;
                                    
                                    vec3 f = fract(uv); 
                                    f = f * f * (3.0 - 2.0 * f);
                                    
                                    vec4 v = vec4(uv0.x + uv0.y + uv0.z, uv1.x + uv0.y + uv0.z,
                                                 uv0.x + uv1.y + uv0.z, uv1.x + uv1.y + uv0.z);
                                    
                                    vec4 r = fract(sin(v * 1e-3) * 1e5);
                                    float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
                                    
                                    r = fract(sin((v + uv1.z - uv0.z) * 1e-3) * 1e5);
                                    float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
                                    
                                    return mix(r0, r1, f.z) * 2.0 - 1.0;
                                }
                                
                                void main() {
                                    // 模拟音频频率（使用时间变化代替）
                                    float freqs[4];
                                    freqs[0] = 0.3 + sin(uTime * 2.0) * 0.2;
                                    freqs[1] = 0.4 + sin(uTime * 3.0) * 0.3;
                                    freqs[2] = 0.5 + sin(uTime * 4.0) * 0.25;
                                    freqs[3] = 0.3 + sin(uTime * 5.0) * 0.2;
                                    
                                    float brightness = freqs[1] * 0.25 + freqs[2] * 0.25;
                                    float radius = 0.24 + brightness * 0.2;
                                    float invRadius = 1.0 / radius;
                                    
                                    vec3 orange = vec3(0.8, 0.65, 0.3);
                                    vec3 orangeRed = vec3(0.8, 0.35, 0.1);
                                    float time = uTime * 0.1;
                                    
                                    // 使用UV坐标，适配到球体
                                    vec2 uv = vUv;
                                    vec2 p = -0.5 + uv;
                                    float aspect = 1.0;
                                    p.x *= aspect;
                                    
                                    float fade = pow(length(2.0 * p), 0.5);
                                    float fVal1 = 1.0 - fade;
                                    float fVal2 = 1.0 - fade;
                                    
                                    float angle = atan(p.x, p.y) / 6.2832;
                                    float dist = length(p);
                                    vec3 coord = vec3(angle, dist, time * 0.1);
                                    
                                    float newTime1 = abs(snoise(coord + vec3(0.0, -time * (0.35 + brightness * 0.001), time * 0.015), 15.0));
                                    float newTime2 = abs(snoise(coord + vec3(0.0, -time * (0.15 + brightness * 0.001), time * 0.015), 45.0));
                                    
                                    for (int i = 1; i <= 7; i++) {
                                        float power = pow(2.0, float(i + 1));
                                        fVal1 += (0.5 / power) * snoise(coord + vec3(0.0, -time, time * 0.2), (power * (10.0) * (newTime1 + 1.0)));
                                        fVal2 += (0.5 / power) * snoise(coord + vec3(0.0, -time, time * 0.2), (power * (25.0) * (newTime2 + 1.0)));
                                    }
                                    
                                    float corona = pow(fVal1 * max(1.1 - fade, 0.0), 2.0) * 50.0;
                                    corona += pow(fVal2 * max(1.1 - fade, 0.0), 2.0) * 50.0;
                                    corona *= 1.2 - newTime1;
                                    
                                    vec3 starSphere = vec3(0.0);
                                    
                                    vec2 sp = -1.0 + 2.0 * uv;
                                    sp.x *= aspect;
                                    sp *= (2.0 - brightness);
                                    float r = dot(sp, sp);
                                    float f = (1.0 - sqrt(abs(1.0 - r))) / (r) + brightness * 0.5;
                                    
                                    if (dist < radius) {
                                        corona *= pow(dist * invRadius, 24.0);
                                        vec2 newUv;
                                        newUv.x = sp.x * f;
                                        newUv.y = sp.y * f;
                                        newUv += vec2(time, 0.0);
                                        
                                        // 使用噪声代替纹理采样
                                        vec3 texSample = vec3(
                                            snoise(vec3(newUv, time), 10.0) * 0.5 + 0.5,
                                            snoise(vec3(newUv, time + 1.0), 10.0) * 0.5 + 0.5,
                                            snoise(vec3(newUv, time + 2.0), 10.0) * 0.5 + 0.5
                                        );
                                        
                                        float uOff = (texSample.g * brightness * 4.5 + time);
                                        vec2 starUV = newUv + vec2(uOff, 0.0);
                                        starSphere = vec3(
                                            snoise(vec3(starUV, time), 8.0) * 0.5 + 0.5,
                                            snoise(vec3(starUV, time + 1.0), 8.0) * 0.5 + 0.5,
                                            snoise(vec3(starUV, time + 2.0), 8.0) * 0.5 + 0.5
                                        ) * 0.3;
                                    }
                                    
                                    float starGlow = min(max(1.0 - dist * (1.0 - brightness), 0.0), 1.0);
                                    
                                    vec3 finalColor = vec3(f * (0.75 + brightness * 0.3) * orange) + starSphere + corona * orange + starGlow * orangeRed;
                                    
                                    gl_FragColor = vec4(finalColor, 1.0);
                                }
                            `

                            const sunMaterial = new THREE.ShaderMaterial({
                                uniforms: {
                                    uTime: { value: 0.0 },
                                    uSunColor: {
                                        value: new THREE.Color(0xffd700),
                                    },
                                    uFlameColor: {
                                        value: new THREE.Color(0xff4500),
                                    },
                                },
                                vertexShader: sunVertexShader,
                                fragmentShader: sunFragmentShader,
                            })

                            const sun = new THREE.Mesh(sunGeometry, sunMaterial)
                            this.scene.add(sun)
                            this.sun = sun // 保存引用用于更新uniform

                            const glowGeometry1 = new THREE.SphereGeometry(
                                3.2,
                                32,
                                32
                            )
                            const glowMaterial1 = new THREE.MeshBasicMaterial({
                                color: 0xffa500,
                                transparent: true,
                                opacity: 0.4,
                            })
                            const sunGlow1 = new THREE.Mesh(
                                glowGeometry1,
                                glowMaterial1
                            )
                            this.scene.add(sunGlow1)

                            const glowGeometry2 = new THREE.SphereGeometry(
                                3.4,
                                32,
                                32
                            )
                            const glowMaterial2 = new THREE.MeshBasicMaterial({
                                color: 0xff8c00,
                                transparent: true,
                                opacity: 0.2,
                            })
                            const sunGlow2 = new THREE.Mesh(
                                glowGeometry2,
                                glowMaterial2
                            )
                            this.scene.add(sunGlow2)

                            const glowGeometry3 = new THREE.SphereGeometry(
                                3.8,
                                32,
                                32
                            )
                            const glowMaterial3 = new THREE.MeshBasicMaterial({
                                color: 0xff6347,
                                transparent: true,
                                opacity: 0.1,
                            })
                            const sunGlow3 = new THREE.Mesh(
                                glowGeometry3,
                                glowMaterial3
                            )
                            this.scene.add(sunGlow3)

                            this.sunGlows = [sunGlow1, sunGlow2, sunGlow3]
                        }

                        /**
                         * 创建所有行星
                         * 为每个行星创建几何体、材质、轨道，并添加到场景中
                         * 根据行星类型设置不同的材质属性（粗糙度、金属度等）
                         */
                        createPlanets() {
                            this.planetData.forEach((data, index) => {
                                const planetGroup = new THREE.Group()

                                const planetGeometry = new THREE.SphereGeometry(
                                    data.radius,
                                    64,
                                    64
                                )
                                const texture = this.createPlanetTexture(
                                    data.textureType
                                )

                                let materialProps = {
                                    map: texture,
                                    roughness: 0.7,
                                    metalness: 0.1,
                                    emissive: 0x000000,
                                    emissiveIntensity: 0,
                                }

                                switch (data.textureType) {
                                    case 'mercury':
                                        materialProps.roughness = 0.9
                                        materialProps.metalness = 0.3
                                        break
                                    case 'venus':
                                        materialProps.roughness = 0.8
                                        materialProps.metalness = 0.2
                                        materialProps.emissive = 0xffaa00
                                        materialProps.emissiveIntensity = 0.05
                                        break
                                    case 'earth':
                                        materialProps.roughness = 0.6
                                        materialProps.metalness = 0.1
                                        break
                                    case 'mars':
                                        materialProps.roughness = 0.8
                                        materialProps.metalness = 0.15
                                        break
                                    case 'jupiter':
                                        materialProps.roughness = 0.5
                                        materialProps.metalness = 0.05
                                        break
                                    case 'saturn':
                                        materialProps.roughness = 0.4
                                        materialProps.metalness = 0.08
                                        break
                                    case 'uranus':
                                        materialProps.roughness = 0.6
                                        materialProps.metalness = 0.12
                                        materialProps.emissive = 0x4fd0e0
                                        materialProps.emissiveIntensity = 0.02
                                        break
                                    case 'neptune':
                                        materialProps.roughness = 0.5
                                        materialProps.metalness = 0.15
                                        materialProps.emissive = 0x4169e1
                                        materialProps.emissiveIntensity = 0.02
                                        break
                                }

                                const planetMaterial =
                                    new THREE.MeshStandardMaterial(
                                        materialProps
                                    )
                                const planet = new THREE.Mesh(
                                    planetGeometry,
                                    planetMaterial
                                )
                                planet.castShadow = true
                                planet.receiveShadow = true
                                planet.userData = data
                                planet.userData.index = index

                                planet.position.x = data.distance

                                if (data.textureType === 'saturn') {
                                    this.createSaturnRings(
                                        planetGroup,
                                        data.radius
                                    )
                                }

                                // 创建轨道线（使用 BasicMaterial，不受光照影响）
                                const orbitGeometry = new THREE.RingGeometry(
                                    data.distance - 0.1,
                                    data.distance + 0.1,
                                    64
                                )
                                // 使用 MeshBasicMaterial 创建轨道材质，不受光照影响，始终显示
                                const orbitMaterial =
                                    new THREE.MeshBasicMaterial({
                                        color: 0xcbd5e1, // Slate 300
                                        transparent: true, // 启用透明度
                                        opacity: 0.2, // 20% 不透明度
                                        side: THREE.DoubleSide, // 双面渲染
                                    })
                                const orbit = new THREE.Mesh(
                                    orbitGeometry,
                                    orbitMaterial
                                )
                                orbit.rotation.x = -Math.PI / 2 // 旋转到水平面
                                this.scene.add(orbit)

                                planetGroup.add(planet)
                                this.scene.add(planetGroup)

                                this.planets.push({
                                    group: planetGroup,
                                    mesh: planet,
                                    data: data,
                                    angle: Math.random() * Math.PI * 2,
                                })
                            })
                        }

                        /**
                         * 创建土星光环
                         * 土星有三层光环，由内到外逐渐变淡，模拟真实的光环效果
                         * @param {THREE.Group} planetGroup - 行星组对象
                         * @param {number} planetRadius - 行星半径
                         */
                        createSaturnRings(planetGroup, planetRadius) {
                            const ringGeometry = new THREE.RingGeometry(
                                planetRadius * 1.5,
                                planetRadius * 2.5,
                                128
                            )
                            const ringMaterial = new THREE.MeshStandardMaterial(
                                {
                                    color: 0xdeb887,
                                    transparent: true,
                                    opacity: 0.8,
                                    side: THREE.DoubleSide,
                                    roughness: 0.6,
                                    metalness: 0.1,
                                }
                            )
                            const rings = new THREE.Mesh(
                                ringGeometry,
                                ringMaterial
                            )
                            rings.rotation.x = -Math.PI / 2.5
                            rings.castShadow = true
                            rings.receiveShadow = true
                            planetGroup.add(rings)

                            const ringGeometry2 = new THREE.RingGeometry(
                                planetRadius * 2.6,
                                planetRadius * 3.0,
                                128
                            )
                            const ringMaterial2 =
                                new THREE.MeshStandardMaterial({
                                    color: 0xf4a460,
                                    transparent: true,
                                    opacity: 0.6,
                                    side: THREE.DoubleSide,
                                    roughness: 0.7,
                                    metalness: 0.05,
                                })
                            const rings2 = new THREE.Mesh(
                                ringGeometry2,
                                ringMaterial2
                            )
                            rings2.rotation.x = -Math.PI / 2.5
                            rings2.castShadow = true
                            rings2.receiveShadow = true
                            planetGroup.add(rings2)

                            const ringGeometry3 = new THREE.RingGeometry(
                                planetRadius * 3.1,
                                planetRadius * 3.4,
                                128
                            )
                            const ringMaterial3 =
                                new THREE.MeshStandardMaterial({
                                    color: 0xffdead,
                                    transparent: true,
                                    opacity: 0.4,
                                    side: THREE.DoubleSide,
                                    roughness: 0.8,
                                    metalness: 0.02,
                                })
                            const rings3 = new THREE.Mesh(
                                ringGeometry3,
                                ringMaterial3
                            )
                            rings3.rotation.x = -Math.PI / 2.5
                            rings3.castShadow = true
                            rings3.receiveShadow = true
                            planetGroup.add(rings3)
                        }

                        /**
                         * 设置所有事件监听器
                         * 包括鼠标事件（拖拽、点击、滚轮）、触摸事件（单指旋转、双指缩放）、UI控件事件等
                         */
                        setupEventListeners() {
                            const canvas = document.getElementById('canvas')

                            canvas.addEventListener('mousedown', (e) => {
                                this.isDragging = true
                                this.lastMouseX = e.clientX
                                this.lastMouseY = e.clientY
                            })

                            canvas.addEventListener('mousemove', (e) => {
                                if (this.isDragging) {
                                    const deltaX = e.clientX - this.lastMouseX
                                    const deltaY = e.clientY - this.lastMouseY

                                    this.targetRotationY += deltaX * 0.01
                                    this.targetRotationX += deltaY * 0.01

                                    this.targetRotationX = Math.max(
                                        -Math.PI / 3,
                                        Math.min(
                                            Math.PI / 3,
                                            this.targetRotationX
                                        )
                                    )

                                    this.lastMouseX = e.clientX
                                    this.lastMouseY = e.clientY
                                }
                            })

                            canvas.addEventListener('mouseup', () => {
                                this.isDragging = false
                            })

                            canvas.addEventListener('mouseleave', () => {
                                this.isDragging = false
                            })

                            canvas.addEventListener('click', (e) => {
                                if (!this.isDragging) {
                                    this.checkPlanetClick(e)
                                }
                            })

                            canvas.addEventListener('wheel', (e) => {
                                e.preventDefault()
                                this.cameraDistance += e.deltaY * 0.05
                                this.cameraDistance = Math.max(
                                    10,
                                    Math.min(100, this.cameraDistance)
                                )
                            })

                            let touchStartDistance = 0
                            let touchStartRotationX = 0
                            let touchStartRotationY = 0
                            let lastTouchX = 0
                            let lastTouchY = 0

                            canvas.addEventListener('touchstart', (e) => {
                                e.preventDefault()
                                if (e.touches.length === 1) {
                                    this.isDragging = true
                                    lastTouchX = e.touches[0].clientX
                                    lastTouchY = e.touches[0].clientY
                                    touchStartRotationX = this.targetRotationX
                                    touchStartRotationY = this.targetRotationY
                                } else if (e.touches.length === 2) {
                                    this.isDragging = false
                                    const dx =
                                        e.touches[0].clientX -
                                        e.touches[1].clientX
                                    const dy =
                                        e.touches[0].clientY -
                                        e.touches[1].clientY
                                    touchStartDistance = Math.sqrt(
                                        dx * dx + dy * dy
                                    )
                                }
                            })

                            canvas.addEventListener('touchmove', (e) => {
                                e.preventDefault()
                                if (e.touches.length === 1 && this.isDragging) {
                                    const deltaX =
                                        e.touches[0].clientX - lastTouchX
                                    const deltaY =
                                        e.touches[0].clientY - lastTouchY

                                    this.targetRotationY =
                                        touchStartRotationY + deltaX * 0.01
                                    this.targetRotationX =
                                        touchStartRotationX + deltaY * 0.01

                                    this.targetRotationX = Math.max(
                                        -Math.PI / 3,
                                        Math.min(
                                            Math.PI / 3,
                                            this.targetRotationX
                                        )
                                    )
                                } else if (e.touches.length === 2) {
                                    const dx =
                                        e.touches[0].clientX -
                                        e.touches[1].clientX
                                    const dy =
                                        e.touches[0].clientY -
                                        e.touches[1].clientY
                                    const distance = Math.sqrt(
                                        dx * dx + dy * dy
                                    )

                                    if (touchStartDistance > 0) {
                                        const scale =
                                            distance / touchStartDistance
                                        this.cameraDistance =
                                            this.cameraDistance / scale
                                        this.cameraDistance = Math.max(
                                            10,
                                            Math.min(100, this.cameraDistance)
                                        )
                                        touchStartDistance = distance
                                    }
                                }
                            })

                            canvas.addEventListener('touchend', (e) => {
                                e.preventDefault()
                                this.isDragging = false
                                touchStartDistance = 0
                            })

                            canvas.addEventListener('touchcancel', (e) => {
                                e.preventDefault()
                                this.isDragging = false
                                touchStartDistance = 0
                            })

                            const speedSlider =
                                document.getElementById('speedSlider')
                            speedSlider.addEventListener('input', (e) => {
                                this.speed = parseFloat(e.target.value)
                                document.getElementById(
                                    'speedValue'
                                ).textContent = this.speed.toFixed(1)
                            })

                            const playPauseBtn =
                                document.getElementById('playPauseBtn')
                            playPauseBtn.addEventListener('click', () => {
                                this.isPaused = !this.isPaused
                                playPauseBtn.innerHTML = this.isPaused
                                    ? '<span class="material-icons" style="font-size: 16px; vertical-align: middle;">play_arrow</span>播放'
                                    : '<span class="material-icons" style="font-size: 16px; vertical-align: middle;">pause</span>暂停'
                            })

                            const resetBtn = document.getElementById('resetBtn')
                            resetBtn.addEventListener('click', () => {
                                this.cameraDistance = 50
                                this.targetRotationX = 0
                                this.targetRotationY = 0
                                this.speed = 1.0
                                document.getElementById(
                                    'speedSlider'
                                ).value = 1.0
                                document.getElementById(
                                    'speedValue'
                                ).textContent = '1.0'
                            })

                            const closePlanetInfo =
                                document.getElementById('closePlanetInfo')
                            closePlanetInfo.addEventListener('click', () => {
                                document.getElementById(
                                    'planetInfo'
                                ).style.display = 'none'
                            })

                            window.addEventListener('resize', () => {
                                this.camera.aspect =
                                    window.innerWidth / window.innerHeight
                                this.camera.updateProjectionMatrix()
                                this.renderer.setSize(
                                    window.innerWidth,
                                    window.innerHeight
                                )
                            })
                        }

                        /**
                         * 检测鼠标点击是否命中行星
                         * 使用射线投射（Raycasting）技术检测点击，如果命中行星则显示信息面板
                         * @param {MouseEvent} event - 鼠标点击事件
                         */
                        checkPlanetClick(event) {
                            const raycaster = new THREE.Raycaster()
                            const mouse = new THREE.Vector2()

                            mouse.x =
                                (event.clientX / window.innerWidth) * 2 - 1
                            mouse.y =
                                -(event.clientY / window.innerHeight) * 2 + 1

                            raycaster.setFromCamera(mouse, this.camera)

                            const planetMeshes = this.planets.map((p) => p.mesh)
                            const intersects =
                                raycaster.intersectObjects(planetMeshes)

                            if (intersects.length > 0) {
                                const clickedPlanet = intersects[0].object
                                this.showPlanetInfo(clickedPlanet.userData)
                            }
                        }

                        /**
                         * 显示行星信息面板
                         * 在屏幕中央显示行星的详细信息（名称、直径、距离、公转周期）
                         * @param {Object} planetData - 行星数据对象
                         */
                        showPlanetInfo(planetData) {
                            const infoPanel =
                                document.getElementById('planetInfo')
                            document.getElementById('planetName').textContent =
                                planetData.name
                            document.getElementById(
                                'planetDiameter'
                            ).textContent = planetData.diameter
                            document.getElementById(
                                'planetDistance'
                            ).textContent = planetData.realDistance
                            document.getElementById(
                                'planetPeriod'
                            ).textContent = planetData.period

                            infoPanel.style.display = 'block'
                            infoPanel.style.left = '50%'
                            infoPanel.style.top = '50%'
                            infoPanel.style.transform = 'translate(-50%, -50%)'
                        }

                        /**
                         * 动画循环函数
                         * 每帧更新行星位置（公转）、行星旋转（自转）、太阳光晕动画、相机位置等
                         * 使用requestAnimationFrame实现流畅的动画效果
                         */
                        animate() {
                            this.animationId = requestAnimationFrame(() =>
                                this.animate()
                            )

                            if (!this.isPaused) {
                                this.planets.forEach((planet) => {
                                    planet.angle +=
                                        planet.data.speed * this.speed * 0.01
                                    planet.mesh.position.x =
                                        Math.cos(planet.angle) *
                                        planet.data.distance
                                    planet.mesh.position.z =
                                        Math.sin(planet.angle) *
                                        planet.data.distance
                                    planet.mesh.rotation.y += 0.01 * this.speed
                                })

                                // 更新太阳光晕动画
                                if (this.sunGlows) {
                                    this.sunGlows.forEach((glow, index) => {
                                        const time = Date.now() * 0.001
                                        const scale =
                                            1 +
                                            Math.sin(time * (index + 1) * 0.5) *
                                                0.05
                                        glow.scale.setScalar(scale)
                                    })
                                }
                            }

                            this.currentRotationX +=
                                (this.targetRotationX - this.currentRotationX) *
                                0.1
                            this.currentRotationY +=
                                (this.targetRotationY - this.currentRotationY) *
                                0.1

                            this.camera.position.x =
                                Math.sin(this.currentRotationY) *
                                Math.cos(this.currentRotationX) *
                                this.cameraDistance
                            this.camera.position.y =
                                Math.sin(this.currentRotationX) *
                                this.cameraDistance
                            this.camera.position.z =
                                Math.cos(this.currentRotationY) *
                                Math.cos(this.currentRotationX) *
                                this.cameraDistance
                            this.camera.lookAt(0, 0, 0)

                            this.renderer.render(this.scene, this.camera)
                        }
                    }

                    new SolarSystem()
                })
                .catch((error) => {
                    console.error('Failed to load Three.js:', error)
                })
        </script>
        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                background: #000814;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI',
                    Roboto, sans-serif;
            }

            #container {
                width: 100vw;
                height: 100vh;
                position: relative;
                margin-left: 0;
                margin-right: 0;
            }

            #canvas {
                width: 100%;
                height: 100%;
                display: block;
            }

            .control-panel {
                position: absolute;
                top: 20px;
                left: 20px;
                background: rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                padding: 20px;
                min-width: 280px;
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
            }

            .planet-info {
                position: absolute;
                background: rgba(255, 255, 255, 0.95);
                border-radius: 12px;
                padding: 20px;
                min-width: 250px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                display: none;
                color: #333;
            }

            .speed-slider {
                width: 100%;
                margin: 10px 0;
            }

            .btn {
                background: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(255, 255, 255, 0.3);
                color: white;
                padding: 8px 16px;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
                margin: 5px;
            }

            .btn:hover {
                background: rgba(255, 255, 255, 0.3);
                transform: translateY(-2px);
            }

            .btn.active {
                background: rgba(255, 255, 255, 0.4);
            }
        </style>
        <script>
            window.artifactId = 'flashapp-8599a7ee15fc446c'
            window.artifactVersion = '4'
            window.trace_id = '0b43c4d817648697972326690e4efe'
        </script>
        <meta
            http-equiv="Content-Security-Policy"
            content="
  script-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: *.alipay.com *.alipayobjects.com  *.amap.com *.lingguang.com *.lingguangcontent.com;
  frame-src 'self' data: blob: *.alipay.com *.alipayobjects.com *.amap.com *.lingguang.com *.lingguangcontent.com;
  connect-src 'self' data: blob: *.alipay.com *.alipayobjects.com  *.amap.com *.lingguang.com *.lingguangcontent.com;
  child-src 'self' data: blob: *.alipay.com *.alipayobjects.com  *.amap.com *.lingguang.com *.lingguangcontent.com;
  object-src 'self' data: blob: *.alipay.com *.alipayobjects.com  *.amap.com *.lingguang.com *.lingguangcontent.com;
  base-uri 'self' *.alipay.com *.alipayobjects.com *.amap.com *.lingguang.com *.lingguangcontent.com;
  form-action 'none';
  upgrade-insecure-requests;
"
        />
    </head>
    <body>
        <div id="container">
            <canvas id="canvas"></canvas>

            <div class="control-panel">
                <h3 class="text-lg font-bold mb-4">太阳系模拟器</h3>

                <div class="mb-4">
                    <label class="block text-sm mb-2">运行速度</label>
                    <input
                        type="range"
                        class="speed-slider"
                        id="speedSlider"
                        min="0"
                        max="10"
                        value="1"
                        step="0.1"
                        data-testid="speed-slider"
                    />
                    <div class="text-xs mt-1">
                        速度: <span id="speedValue">1.0</span>x
                    </div>
                </div>

                <div class="mb-4">
                    <button
                        class="btn"
                        id="playPauseBtn"
                        data-testid="play-pause-btn"
                    >
                        <span
                            class="material-icons"
                            style="font-size: 16px; vertical-align: middle"
                            >pause</span
                        >
                        暂停
                    </button>
                    <button class="btn" id="resetBtn" data-testid="reset-btn">
                        <span
                            class="material-icons"
                            style="font-size: 16px; vertical-align: middle"
                            >refresh</span
                        >
                        重置
                    </button>
                </div>

                <div class="text-xs opacity-75">
                    <p>• 拖拽旋转视角</p>
                    <p>• 滚轮缩放</p>
                    <p>• 点击行星查看信息</p>
                    <p>• 移动端：单指拖拽旋转，双指缩放</p>
                </div>
            </div>

            <div class="planet-info" id="planetInfo">
                <h4 class="font-bold text-lg mb-2" id="planetName"></h4>
                <div class="text-sm space-y-1">
                    <p>直径: <span id="planetDiameter"></span></p>
                    <p>距太阳: <span id="planetDistance"></span></p>
                    <p>公转周期: <span id="planetPeriod"></span></p>
                </div>
                <button
                    class="btn mt-3 text-sm"
                    id="closePlanetInfo"
                    data-testid="close-planet-info"
                >
                    <span
                        class="material-icons"
                        style="font-size: 14px; vertical-align: middle"
                        >close</span
                    >
                    关闭
                </button>
            </div>
        </div>
    </body>
</html>
